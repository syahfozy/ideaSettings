<application>
  <component name="AppStorage">
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="Copyright (C) 2012 The Guava Authors Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:www.apache.orglicensesLICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Escapers for XML. &lt;p&gt;This package is a part of the open-source &lt;a href=&quot;http:github.comgoogleguava&quot;&gt;Guava&lt;a&gt; library. @CheckReturnValue @ParametersAreNonnullByDefault package com.google.common.xml; import javax.annotation.CheckReturnValue; import javax.annotation.ParametersAreNonnullByDefault;" />
      <item value="Signifies that a public API (public class, method or field) is subject to incompatible changes, or even removal, in a future release. An API bearing this annotation is exempt from any compatibility guarantees made by its containing library. Note that the presence of this annotation implies nothing about the quality or performance of the API in question, only the fact that it is not &quot;API-frozen.&quot; &lt;p&gt;It is generally safe for &lt;i&gt;applications&lt;i&gt; to depend on beta APIs, at the cost of some extra work during upgrades. However it is generally inadvisable for &lt;i&gt;libraries&lt;i&gt; (which get included on users' CLASSPATHs, outside the library developers' control) to do so." />
      <item value="A rule to wrap any single attempt in a time limit, where it will possibly be interrupted if the limit is exceeded." />
      <item value="An attempt of a call, which resulted either in a result returned by the call, or in a Throwable thrown by the call." />
      <item value="Computes a result, or throws an exception if unable to do so." />
      <item value="Combine Logger" />
      <item value="Delegating Filter Proxy" />
      <item value="TRAINEE" />
      <item value="send Sky Eye" />
      <item value="Check Sign Param Item" />
      <item value="legal" />
      <item value="mack Id Code" />
      <item value="recognize" />
      <item value="Dynamically" />
      <item value="decrypt" />
      <item value="exposed Object" />
      <item value="do Evaluate" />
      <item value="resolve Bean Class" />
      <item value="canonical Name" />
      <item value="resolve And Count Tmpl Param Task" />
      <item value="resolve" />
      <item value="determine" />
      <item value="determine Constructors From Bean Post Processors" />
      <item value="get Resolved Autowire Mode" />
      <item value="freeze Configuration" />
      <item value="set Temp Class Loader" />
      <item value="Multicaster" />
      <item value="resolve Bean" />
      <item value="apply Bean Post Processors After Initialization" />
      <item value="apply Bean Post Processors Before Initialization" />
      <item value="invoke Aware Methods" />
      <item value="populate Bean" />
      <item value="ctor" />
      <item value="instance Wrapper" />
      <item value="Finish the initialization of this context bean factory, initializing all remaining singleton beans." />
      <item value="Finish the initialization of this context's bean factory, initializing all remaining singleton beans." />
      <item value="Check for listener beans and register them." />
      <item value="Initialize the ApplicationEventMulticaster. Uses SimpleApplicationEventMulticaster if none defined in the context." />
      <item value="invoke Bean Factory Post Processors" />
      <item value="register Bean Post Processors" />
      <item value="post Process Bean Factory" />
      <item value="prepare Bean Factory" />
      <item value="Default Listable Bean Factory" />
      <item value="Configurable Listable Bean Factory" />
      <item value="obtain Fresh Bean Factory" />
      <item value="prepare Refresh" />
      <item value="assemble" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="48" />
        <entry key="ENGLISH" value="49" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1674826721317" />
  </component>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1722043351695" />
  </component>
  <component name="Translation.Settings">
    <option name="primaryFontPreviewText" value="This is a sample&#10;multiline text" />
    <option name="primaryLanguage" value="CHINESE" />
  </component>
  <component name="Translation.States">
    <histories>
      <item value="Class Worker mainly maintains interrupt control state for threads running tasks, along with other minor bookkeeping. This class opportunistically extends AbstractQueuedSynchronizer to simplify acquiring and releasing a lock surrounding each task execution. This protects against interrupts that are intended to wake up a worker thread waiting for a task from instead interrupting a task being run. We implement a simple non-reentrant mutual exclusion lock rather than use ReentrantLock because we do not want worker tasks to be able to reacquire the lock when they invoke pool control methods like setCorePoolSize. Additionally, to suppress interrupts until the thread actually starts running tasks, we initialize lock state to a negative value, and clear it upon start (in runWorker)." />
      <item value="@Override" />
      <item value="Meaningful only if the MaxLen entry is present in the text field dictionary and if the Multiline, Password, and FileSelect flags are clear. If true, the field is automatically divided into as many equally spaced positions, or combs, as the value of MaxLen, and the text is laid out into those combs. Returns: whether or not combing is enabled" />
      <item value="value – of the field generateAppearance – set this flat to false if you want to keep the appearance of the field generated before" />
      <item value="apparently First Queued Is Exclusive" />
      <item value="As a heuristic to avoid indefinite writer starvation, block if the thread that momentarily appears to be head of queue, if one exists, is a waiting writer. This is only a probabilistic effect since a new reader will not block if there is a waiting writer behind other enabled readers that have not yet drained from the queue." />
      <item value="This code is in part redundant with that in tryAcquireShared but is simpler overall by not complicating tryAcquireShared with interactions between retries and lazily reading hold counts." />
      <item value="is Held Exclusively" />
      <item value="Block current thread, returning when a balancing unpark occurs, or a balancing unpark has already occurred, or the thread is interrupted, or, if not absolute and time is not zero, the given time nanoseconds have elapsed, or if absolute, the given deadline in milliseconds since Epoch has passed, or spuriously (i.e., returning for no &quot;reason&quot;). Note: This operation is in the Unsafe class only because unpark is, so it would be strange to place it elsewhere." />
      <item value="Atomically increments by one the current value of the field of the given object managed by this updater." />
      <item value="he array buffer into which the elements of the ArrayList are stored. The capacity of the ArrayList is the length of this array buffer. Any empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA will be expanded to DEFAULT_CAPACITY when the first element is added." />
      <item value="The array buffer into which the elements of the ArrayList are stored. The capacity of the ArrayList is the length of this array buffer. Any empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA will be expanded to DEFAULT_CAPACITY when the first element is added." />
      <item value="InheritableThreadLocal values pertaining to this thread. This map is maintained by the InheritableThreadLocal class." />
      <item value="ThreadLocal values pertaining to this thread. This map is maintained by the ThreadLocal class." />
      <item value="For autonumbering anonymous threads." />
      <item value="Factory and utility methods for" />
      <item value="A Future which forwards all its method calls to another future. Subclasses should override one or more methods to modify the behavior of the backing future as desired per the decorator pattern ." />
      <item value="Forwarding Future" />
      <item value="An immutable snapshot of the current state of the service. This class represents a consistent snapshot of the state and therefore it can be used to answer simple queries without needing to grab a lock." />
      <item value="{@link ConcurrencyReducer} is used to queue tasks which will be executed in a manner reducing the number of concurrent tasks. Note: This is a port of ConcurrencyLimiter from futures-extra for use with CompletionStages" />
      <item value="Returns a new {@link CompletableFuture} which completes to a list of values of those input stages that succeeded. The list of results is in the same order as the input stages. For failed stages, the defaultValueMapper will be called, and the value returned from that function will be put in the resulting list. &lt;p&gt;If no stages are provided, returns a future holding an empty list. @param stages the stages to combine. @param defaultValueMapper a function that will be called when a future completes exceptionally to provide a default value to place in the resulting list @param &lt;T&gt; the common type of all of the input stages, that determines the type of the output future @return a future that completes to a list of the results of the supplied stages @throws NullPointerException if the stages list or any of its elements are {@code null}" />
      <item value="A stage of a possibly asynchronous computation, that performs an action or computes a value when another CompletionStage completes. A stage completes upon termination of its computation, but this may in turn trigger other dependent stages. The functionality defined in this interface takes only a few basic forms, which expand out to a larger set of methods to capture a range of usage styles: &lt;ul&gt; &lt;li&gt;The computation performed by a stage may be expressed as a Function, Consumer, or Runnable (using methods with names including &lt;em&gt;apply&lt;em&gt;, &lt;em&gt;accept&lt;em&gt;, or &lt;em&gt;run&lt;em&gt;, respectively) depending on whether it requires arguments andor produces results. For example, {@code stage.thenApply(x -&gt; square(x)).thenAccept(x -&gt; System.out.print(x)).thenRun(() -&gt; System.out.println())}. An additional form (&lt;em&gt;compose&lt;em&gt;) applies functions of stages themselves, rather than their results. &lt;li&gt; &lt;li&gt; One stage's execution may be triggered by completion of a single stage, or both of two stages, or either of two stages. Dependencies on a single stage are arranged using methods with prefix &lt;em&gt;then&lt;em&gt;. Those triggered by completion of &lt;em&gt;both&lt;em&gt; of two stages may &lt;em&gt;combine&lt;em&gt; their results or effects, using correspondingly named methods. Those triggered by &lt;em&gt;either&lt;em&gt; of two stages make no guarantees about which of the results or effects are used for the dependent stage's computation.&lt;li&gt; &lt;li&gt; Dependencies among stages control the triggering of computations, but do not otherwise guarantee any particular ordering. Additionally, execution of a new stage's computations may be arranged in any of three ways: default execution, default asynchronous execution (using methods with suffix &lt;em&gt;async&lt;em&gt; that employ the stage's default asynchronous execution facility), or custom (via a supplied {@link Executor}). The execution properties of default and async modes are specified by CompletionStage implementations, not this interface. Methods with explicit Executor arguments may have arbitrary execution properties, and might not even support concurrent execution, but are arranged for processing in a way that accommodates asynchrony. &lt;li&gt; Two method forms support processing whether the triggering stage completed normally or exceptionally: Method {@link whenComplete whenComplete} allows injection of an action regardless of outcome, otherwise preserving the outcome in its completion. Method {@link handle handle} additionally allows the stage to compute a replacement result that may enable further processing by other dependent stages. In all other cases, if a stage's computation terminates abruptly with an (unchecked) exception or error, then all dependent stages requiring its completion complete exceptionally as well, with a {@link CompletionException} holding the exception as its cause. If a stage is dependent on &lt;em&gt;both&lt;em&gt; of two stages, and both complete exceptionally, then the CompletionException may correspond to either one of these exceptions. If a stage is dependent on &lt;em&gt;either&lt;em&gt; of two others, and only one of them completes exceptionally, no guarantees are made about whether the dependent stage completes normally or exceptionally. In the case of method {@code whenComplete}, when the supplied action itself encounters an exception, then the stage exceptionally completes with this exception if not already completed exceptionally.&lt;li&gt; &lt;ul&gt; &lt;p&gt;All methods adhere to the above triggering, execution, and exceptional completion specifications (which are not repeated in individual method specifications). Additionally, while arguments used to pass a completion result (that is, for parameters of type {@code T}) for methods accepting them may be null, passing a null value for any other parameter will result in a {@link NullPointerException} being thrown. &lt;p&gt;This interface does not define methods for initially creating, forcibly completing normally or exceptionally, probing completion status or results, or awaiting completion of a stage. Implementations of CompletionStage may provide means of achieving such effects, as appropriate. Method {@link toCompletableFuture} enables interoperability among different implementations of this interface by providing a common conversion type." />
      <item value="One or more variables that together maintain an initially zero {@code long} sum. When updates (method {@link add}) are contended across threads, the set of variables may grow dynamically to reduce contention. Method {@link sum} (or, equivalently, {@link longValue}) returns the current total combined across the variables maintaining the sum. &lt;p&gt;This class is usually preferable to {@link AtomicLong} when multiple threads update a common sum that is used for purposes such as collecting statistics, not for fine-grained synchronization control. Under low update contention, the two classes have similar characteristics. But under high contention, expected throughput of this class is significantly higher, at the expense of higher space consumption. &lt;p&gt;This class extends {@link Number}, but does &lt;em&gt;not&lt;em&gt; define methods such as {@code equals}, {@code hashCode} and {@code compareTo} because instances are expected to be mutated, and so are not useful as collection keys. &lt;p&gt;&lt;em&gt;jsr166e note: This class is targeted to be placed in java.util.concurrent.atomic.&lt;em&gt; @since 1.8 @author Doug Lea" />
      <item value="An immutable object that may contain a non-null reference to another object. Each instance of this type either contains a non-null reference, or contains nothing (in which case we say that the reference is &quot;absent&quot;); it is never said to &quot;contain null&quot;. A non-null Optional reference can be used as a replacement for a nullable T reference. It allows you to represent &quot;a T that must be present&quot; and a &quot;a T that might be absent&quot; as two distinct types in your program, which can aid clarity. Some uses of this class include As a method return type, as an alternative to returning null to indicate that no value was available To distinguish between &quot;unknown&quot; (for example, not present in a map) and &quot;known to have no value&quot; (present in the map, with value Optional.absent()) To wrap nullable references for storage in a collection that does not support null (though there are several other approaches to this that should be considered first) A common alternative to using this class is to find or create a suitable null object for the type in question. This class is not intended as a direct analogue of any existing &quot;option&quot; or &quot;maybe&quot; construct from other programming environments, though it may bear some similarities. Comparison to java.util.Optional (JDK 8 and higher): A new Optional class was added for Java 8. The two classes are extremely similar, but incompatible (they cannot share a common supertype). All known differences are listed either here or with the relevant methods below. This class is serializable; java.util.Optional is not. java.util.Optional has the additional methods ifPresent, filter, flatMap, and orElseThrow. java.util offers the primitive-specialized versions OptionalInt, OptionalLong and OptionalDouble, the use of which is recommended; Guava does not have these. There are no plans to deprecate this class in the foreseeable future. However, we do gently recommend that you prefer the new, standard Java class whenever possible. See the Guava User Guide article on using Optional. Since: 10.0 Author: Kurt Alfred Kluever, Kevin Bourrillion Type parameters: &lt;T&gt; – the type of instance that can be contained. Optional is naturally covariant on this type, so it is safe to cast an Optional to Optional for any supertype S of T." />
      <item value="Creates a {@code ListenableFuture} which has its value set immediately upon construction. The getters just return the value. This {@code Future} can't be canceled or timed out and its {@code isDone()} method always returns {@code true}." />
      <item value="is Assignable From" />
      <item value="pickup Topic Route Data" />
      <item value="set Compress Msg Body Over Howmuch" />
      <item value="memoize" />
      <item value="try Optimistic Read" />
      <item value="Waits at most millis milliseconds for this thread to die. A timeout of 0 means to wait forever. This implementation uses a loop of this.wait calls conditioned on this.isAlive. As a thread terminates the this.notifyAll method is invoked. It is recommended that applications not use wait, notify, or notifyAll on Thread instances" />
      <item value="不满意" />
      <item value="淘汰" />
      <item value="建议其他岗位面试" />
      <item value="非常满意" />
      <item value="满意" />
      <item value="province" />
      <item value="provence" />
      <item value="252383" />
      <item value="&gt;All commands return a {@link CompletableFuture}. A cache client may choose to wait for the operation to complete or not. As of version 2.0 all operations are completed instantly within the calling thread. This will change in later versions. &lt;p&gt;Outlook: Could get ability to control expiry and refresh behavior, as well as disable the cache." />
      <item value="Interface to the cache2k implementation. This interface is not intended for the application usage. Use the static methods on the {@link CacheManager}." />
      <item value="Wrapper class that forwards all method calls to a delegate. Can be used to implement extensions that need to intercept calls to the cache." />
      <item value="Parent for all interfaces dealing with cached data. This is used to establish a common contract for the K and V type parameter." />
      <item value="package org.cache2k; - %L cache2k API %% Copyright (C) 2000 - 2022 headissue GmbH, Munich %% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:www.apache.orglicensesLICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. L% import org.cache2k.annotation.Nullable; import org.cache2k.io.CacheLoaderException; import org.cache2k.io.ExceptionPropagator; import org.cache2k.io.LoadExceptionInfo; import org.cache2k.processor.MutableCacheEntry; Object representing a cache entry. With the cache entry, it can be checked whether a mapping in the cache is present, even if the cache contains {@code null} or contains an exception. Entries can be retrieved by {@link CachepeekEntry(Object)} or {@link CachegetEntry(Object)} or via iterated via {@link Cacheentries()}. &lt;p&gt;After retrieved, the entry instance does not change its values, even if the value for its key is updated in the cache. &lt;p&gt;Design note: The cache is generally also aware of the time the object will be refreshed next or when it will expire. This is not exposed to applications by intention. @author Jens Wilke @see CachepeekEntry(Object) @see CachegetEntry(Object) @see Cacheentries() public interface CacheEntry&lt;K, V&gt; extends DataAware&lt;K, V&gt; { Key associated with this entry. K getKey(); Value of the entry. The value may be {@code null} if permitted for this cache via {@link Cache2kBuilderpermitNullValues(boolean)}. If the entry had a loader exception which is not suppressed, this exception will be propagated. This can be customized with {@link Cache2kBuilderexceptionPropagator(ExceptionPropagator)} &lt;p&gt;For usage within the {@link org.cache2k.processor.EntryProcessor}: If a loader is present and the entry is not yet loaded or expired, a load is triggered. See the details at: {@link MutableCacheEntrygetValue()} @throws CacheLoaderException if loading produced an exception V getValue(); The exception happened when the value was loaded and the exception could not be suppressed. {@code null} if no exception happened or it was suppressed. If {@code null} then {@link getValue} returns a value and does not throw an exception. default @Nullable Throwable getException() { LoadExceptionInfo&lt;K, V&gt; info = getExceptionInfo(); return info != null ? info.getException() : null; } Detailed information of the latest exception from the loader. {@code null} if no exception happened or was suppressed. If {@code null} then {@link getValue} returns a value and does not throw an exception. @Nullable LoadExceptionInfo&lt;K, V&gt; getExceptionInfo(); }" />
      <item value="Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:www.apache.orglicensesLICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License." />
      <item value="Actuator Web Security" />
      <item value="get Canonical Name" />
      <item value="idempotent" />
      <item value="intern" />
      <item value="Defines the logic to validate a given constraint A for a given object type T. Implementations must comply to the following restriction: T must resolve to a non parameterized type or generic parameters of T must be unbounded wildcard types The annotation SupportedValidationTarget can be put on a ConstraintValidator implementation to mark it as supporting cross-parameter constraints. Check out SupportedValidationTarget and Constraint for more information. Author: Emmanuel Bernard, Hardy Ferentschik" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="53" />
        <entry key="ENGLISH" value="54" />
        <entry key="LATIN" value="1" />
      </map>
    </option>
  </component>
</application>